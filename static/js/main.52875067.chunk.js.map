{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","state","mouseIsPressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","visualizeDijkstra","style","color","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.52875067.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\n// Change node colors depending on isStart, isFinish\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","/* Dijkstra's Algorithms */\n/* How it works:\nFor this algorithm, we set the distance of every node to infinity. Except the starting node. Therefore startNode.distance = 0.\nFirst step, go to the closest node (startNode).\nSecond step, the algorithm updates all of the neighbor nodes of the first node (the nodes at the cardinal points to it in the grid). These nodes now have node.distance + 1.\nRepeat this process until you reach finishNode.\n*/\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  // Loop to find closest node.\n  while (!!unvisitedNodes.length) {\n    // Before visiting a new node, sort it.\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    // If we find a match, visualize/animate it in the order that we visit them.\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\n// Update a neighbor with a new distance and mark it with a previous node (current node).\n// To calculate the shortest path.\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\n// Get the visited neighbours and filter them by !neighbor.isVisited\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  // Initialization\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  // These next 3 handleMouse functions take care of creating the walls in the grid.\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  // Only generate walls if we press on the mouse. (not hover)\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  // Once we let go of mouse button, stop generating walls.\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  // Grab the return value of visitedNodesInOrder = Dijkstra(grid, startNode, finishNode)\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // If we are done with setTimeout.\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          // Then animateShortestPath\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      // Update the class to node-visited.\n      // This is only a hack solution to help with animation speed. (not the best practice)\n      // Since re-rendering the entire component every 10ms was too slow.\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      // Same concept as above, but for shortest path.\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    // First, call dijkstra() to return the array of visited nodes in order.\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    // Then, get the shortest path by starting at the finishNode and making your way back.\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // Then, call animateDijkstra() to return for every node, create a new node off that same node, and mark it as isVisited.\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <>\n        <button className=\"ready\" onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm!\n        </button>\n        <p>Click on the grid to generate walls!</p>\n        <p style={{ color: \"#555\" }}>\n          This app is currently in BETA. I am working on coding new algorithms.\n        </p>\n        <p style={{ color: \"#555\" }}>\n          It will look better in Desktop mode, as I work on new algorithms and\n          better CSS.\n        </p>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            // Iterate through every row and col, then create a node.\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isStart, isFinish, isWall } = node;\n                  return (\n                    // When you render the nodes, pass isStart, isFinish as properties.\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <p style={{ color: \"#555\" }}>\n          Dijkstra's Algorithm will find the shortest path between two nodes.\n        </p>\n      </>\n    );\n  }\n}\n// Create initial grid.\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n// Create node with its properties.\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n// For the handleMouse functions. Toggle between wall or not a wall.\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}